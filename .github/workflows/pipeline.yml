name: Pipeline

on:
  push:
    branches:
      - SinLogin

permissions:
  checks: write # Permite escribir check runs para mostrar resultados de tests
  actions: read # Permite leer acciones
  contents: read # Permite leer el contenido del repositorio

jobs:
  #=======================
  # STAGE: BUILD AND TEST
  #=======================
  build-and-test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install Backend Dependencies
        run: |
          cd backend
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run Backend Tests with Coverage
        run: |
          cd backend
          pytest -v --cov=src --cov-report=html --cov-report=xml --junitxml=pytest-report.xml
      - name: Publish Test Results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Pytest Results
          path: backend/pytest-report.xml
          reporter: java-junit
      - name: Code Coverage Summary
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: backend/coverage.xml
          format: markdown
          output: file
          fail_below_min: false
      - name: Write Coverage to Summary
        run: |
          cat code-coverage-results.md >> $GITHUB_STEP_SUMMARY
      - name: Upload Backend Coverage Report
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage-report
          path: backend/htmlcov/
          if-no-files-found: warn
      - name: Prepare Backend Artifact
        run: |
          mkdir -p backend-artifact
          cp -r backend/src/* backend-artifact/
          cp backend/requirements.txt backend-artifact/
      - name: Upload Backend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-artifact
          path: backend-artifact/
          if-no-files-found: error

  build-and-test-frontend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install Frontend Dependencies
        run: |
          cd frontend
          npm install
      - name: Create Frontend .env File
        run: |
          cd frontend
          echo "VITE_API_URL_QA=${{ secrets.BACKEND_QA_URL }}" > .env
          echo "VITE_API_URL_PROD=${{ secrets.BACKEND_PROD_URL }}" >> .env
          echo "VITE_FRONTEND_URL=${{ secrets.FRONTEND_QA_URL }}" >> .env
      - name: Run Frontend Tests with Coverage
        run: |
          cd frontend
          npm test -- --coverage --ci
      - name: Publish Test Results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Jest Results
          path: frontend/junit.xml
          reporter: jest-junit
      #- name: Write Coverage to Summary
      #  run: |
      #    echo "## Frontend Coverage Summary" >> $GITHUB_STEP_SUMMARY
      #    echo "Extracting coverage from coverage-final.json..." >> $GITHUB_STEP_SUMMARY
      #    if [ ! -f frontend/coverage/coverage-final.json ]; then
      #      echo "Error: coverage-final.json not found" >> $GITHUB_STEP_SUMMARY
      #      echo "| File | Line Coverage |" >> $GITHUB_STEP_SUMMARY
      #      echo "|------|---------------|" >> $GITHUB_STEP_SUMMARY
      #      echo "| All files | N/A |" >> $GITHUB_STEP_SUMMARY
      #      exit 1
      #    fi
      #    # Contar statements totales (claves en statementMap)
      #    TOTAL_STATEMENTS=$(jq '[.[] | .statementMap | length] | add // 0' frontend/coverage/coverage-final.json)
      #    # Contar statements cubiertos (claves en s con valor > 0)
      #    COVERED_STATEMENTS=$(jq '[.[] | .s | to_entries[] | select(.value > 0) | .key] | length // 0' frontend/coverage/coverage-final.json)
      #    echo "Total statements: $TOTAL_STATEMENTS" >> $GITHUB_STEP_SUMMARY
      #    echo "Covered statements: $COVERED_STATEMENTS" >> $GITHUB_STEP_SUMMARY
      #    if [ "$TOTAL_STATEMENTS" -eq 0 ]; then
      #      COVERAGE="0.00%"
      #    else
      #      COVERAGE=$(echo "scale=2; ($COVERED_STATEMENTS * 100) / $TOTAL_STATEMENTS" | bc)
      #      COVERAGE="$COVERAGE%"
      #    fi
      #    echo "| File | Line Coverage |" >> $GITHUB_STEP_SUMMARY
      #    echo "|------|---------------|" >> $GITHUB_STEP_SUMMARY
      #    echo "| All files | $COVERAGE |" >> $GITHUB_STEP_SUMMARY
      - name: Write Coverage to Summary
        run: |
          echo "## Frontend Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Line Rate | Complexity | Health |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----------|------------|--------|" >> $GITHUB_STEP_SUMMARY
              
          if [ ! -f frontend/coverage/coverage-final.json ]; then
            echo "Error: coverage-final.json not found" >> $GITHUB_STEP_SUMMARY
            echo "| All files | N/A | 0 | ❌ |" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
              
          # Verificar si el JSON es un objeto
          JSON_TYPE=$(jq 'type' frontend/coverage/coverage-final.json || echo "invalid")
          if [ "$JSON_TYPE" != "object" ]; then
            echo "Error: coverage-final.json is not a valid object (type: $JSON_TYPE)" >> $GITHUB_STEP_SUMMARY
            echo "| All files | N/A | 0 | ❌ |" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
              
          # Obtener la lista de paquetes (directorios únicos) de forma más robusta
          PACKAGES=$(jq -r 'keys[] | split("/") | if length > 3 then .[0:-1] | join("/") else "." end | unique[]' frontend/coverage/coverage-final.json 2>/dev/null || echo ".")
              
          TOTAL_STATEMENTS_ALL=0
          COVERED_STATEMENTS_ALL=0
              
          # Procesar cada paquete
          for PACKAGE in $PACKAGES; do
            # Convertir paquete a formato para jq
            if [ "$PACKAGE" = "." ]; then
              TOTAL_STATEMENTS=$(jq '[.[] | .statementMap | length] | add // 0' frontend/coverage/coverage-final.json)
              COVERED_STATEMENTS=$(jq '[.[] | .s | to_entries[] | select(.value > 0) | .key] | length // 0' frontend/coverage/coverage-final.json)
            else
              PACKAGE_PATH=$(echo "$PACKAGE" | sed 's/\./\\./g')
              TOTAL_STATEMENTS=$(jq "[.[] | select(.path | test(\"^.*$PACKAGE_PATH\")) | .statementMap | length] | add // 0" frontend/coverage/coverage-final.json)
              COVERED_STATEMENTS=$(jq "[.[] | select(.path | test(\"^.*$PACKAGE_PATH\")) | .s | to_entries[] | select(.value > 0) | .key] | length // 0" frontend/coverage/coverage-final.json)
            fi
              
            # Acumular totales para el resumen
            TOTAL_STATEMENTS_ALL=$((TOTAL_STATEMENTS_ALL + TOTAL_STATEMENTS))
            COVERED_STATEMENTS_ALL=$((COVERED_STATEMENTS_ALL + COVERED_STATEMENTS))
              
            # Calcular porcentaje de cobertura
            if [ "$TOTAL_STATEMENTS" -eq 0 ]; then
              LINE_RATE="0%"
            else
              LINE_RATE=$(echo "scale=2; ($COVERED_STATEMENTS * 100) / $TOTAL_STATEMENTS" | bc)
              LINE_RATE="$LINE_RATE%"
            fi
              
            # Determinar indicador de salud
            if [ "$TOTAL_STATEMENTS" -eq 0 ]; then
              HEALTH="❌"
            else
              LINE_RATE_INT=$(echo "$LINE_RATE" | sed 's/%//')
              if [ $(echo "$LINE_RATE_INT >= 80" | bc) -eq 1 ]; then
                HEALTH="✔"
              elif [ $(echo "$LINE_RATE_INT >= 50" | bc) -eq 1 ]; then
                HEALTH="➖"
              else
                HEALTH="❌"
              fi
            fi
              
            # Añadir fila a la tabla
            echo "| $PACKAGE | $LINE_RATE | 0 | $HEALTH |" >> $GITHUB_STEP_SUMMARY
          done
              
          # Calcular resumen general
          if [ "$TOTAL_STATEMENTS_ALL" -eq 0 ]; then
            SUMMARY_RATE="0%"
            SUMMARY_HEALTH="❌"
          else
            SUMMARY_RATE=$(echo "scale=2; ($COVERED_STATEMENTS_ALL * 100) / $TOTAL_STATEMENTS_ALL" | bc)
            SUMMARY_RATE="$SUMMARY_RATE%"
            if [ $(echo "$SUMMARY_RATE >= 80" | bc) -eq 1 ]; then
              SUMMARY_HEALTH="✔"
            elif [ $(echo "$SUMMARY_RATE >= 50" | bc) -eq 1 ]; then
              SUMMARY_HEALTH="➖"
            else
              SUMMARY_HEALTH="❌"
            fi
          fi
              
          echo "| **Summary** | **$SUMMARY_RATE ($COVERED_STATEMENTS_ALL / $TOTAL_STATEMENTS_ALL)** | **0** | **$SUMMARY_HEALTH** |" >> $GITHUB_STEP_SUMMARY
            - name: Upload Frontend Coverage Report
              uses: actions/upload-artifact@v4
              with:
                name: frontend-coverage-report
                path: frontend/coverage/
                if-no-files-found: warn
            - name: Build Frontend
              run: |
                cd frontend
                npm run build
            - name: Copy staticwebapp.config.json to dist
              run: |
                cp frontend/staticwebapp.config.json frontend/dist/
            - name: Upload Frontend Artifact
              uses: actions/upload-artifact@v4
              with:
                name: frontend-artifact
                path: frontend/dist/
                if-no-files-found: error

  #==========================================
  # STAGE: DEPLOY TO QA AND INTEGRATION TEST
  #==========================================
  deploy-backend-qa:
    needs: build-and-test-backend
    runs-on: ubuntu-latest
    steps:
      - name: Download Backend Artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-artifact
          path: .
      - name: Create Backend Environment File
        run: |
          echo "DATABASE_URL=${{ secrets.DATABASE_QA_URL }}" > env.config
          echo "FRONTEND_URL=${{ secrets.FRONTEND_QA_URL }}" >> env.config
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Deploy to Azure App Service
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'Inversur-QA'
          publish-profile: ${{ secrets.AZURE_APP_SERVICE_PUBLISH_PROFILE_QA }}
      - name: Start Azure App Service
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az webapp start --name Inversur-QA --resource-group Inversur

  deploy-frontend-qa:
    needs: build-and-test-frontend
    runs-on: ubuntu-latest
    steps:
      - name: Download Frontend Artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-artifact
          path: frontend/dist/
      - name: Deploy to Azure Static Web Apps
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_QA }}
          action: "upload"
          app_location: "frontend/dist"
          skip_app_build: true
  
  integration-tests:
    needs: [deploy-backend-qa, deploy-frontend-qa]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install Frontend Dependencies
        run: |
          cd frontend
          npm install
      - name: Create Frontend .env File
        run: |
          cd frontend
          echo "VITE_API_URL_QA=${{ secrets.BACKEND_QA_URL }}" > .env
          echo "VITE_API_URL_PROD=${{ secrets.BACKEND_PROD_URL }}" >> .env
          echo "VITE_FRONTEND_URL=${{ secrets.FRONTEND_QA_URL }}" >> .env
      - name: Run Cypress Tests with Coverage
        run: |
          cd frontend
          npx cypress run --reporter mocha-junit-reporter --reporter-options "mochaFile=cypress/results.xml"
      - name: Publish Test Results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Cypress Results
          path: frontend/cypress/results.xml
          reporter: mocha-junit
      - name: Jest Coverage Report
        uses: ArtiomTr/jest-coverage-report-action@v2
        with:
          working-directory: frontend
          output: report-markdown
      - name: Write Coverage to Summary
        run: |
          cat frontend/report-markdown >> $GITHUB_STEP_SUMMARY
      - name: Upload Cypress Coverage Report
        uses: actions/upload-artifact@v4
        with:
          name: cypress-coverage-report
          path: frontend/coverage/
          if-no-files-found: warn

  #=======================
  # STAGE: DEPLOY TO PROD
  #=======================
  deploy-backend-prod:
    needs: integration-tests
    environment: production
    runs-on: ubuntu-latest
    steps:
      - name: Download Backend Artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-artifact
          path: .
      - name: Create Backend Environment File
        run: |
          echo "DATABASE_URL=${{ secrets.DATABASE_PROD_URL }}" > env.config
          echo "FRONTEND_URL=${{ secrets.FRONTEND_PROD_URL }}" >> env.config
      - name: Login to Azure
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Deploy to Azure App Service
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'Inversur'
          publish-profile: ${{ secrets.AZURE_APP_SERVICE_PUBLISH_PROFILE_PROD }}
      - name: Start Azure App Service
        uses: azure/CLI@v1
        with:
          inlineScript: |
            az webapp start --name Inversur --resource-group Inversur

  deploy-frontend-prod:
    needs: integration-tests
    environment: production
    runs-on: ubuntu-latest
    steps:
      - name: Download Frontend Artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-artifact
          path: frontend/dist/
      - name: Deploy to Azure Static Web Apps
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_PROD }}
          action: "upload"
          app_location: "frontend/dist"
          skip_app_build: true